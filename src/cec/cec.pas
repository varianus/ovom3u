{
This file is part of OvoM3U
Copyright (C) 2020 Marco Caselli

OvoM3U is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

}
unit cec;

{ This unit is automatically generated by Chet:
  https://github.com/neslib/Chet }

{$MINENUMSIZE 4}

interface

const

  {* libCEC's major version number}
  CEC_LIB_VERSION_MAJOR = 6;
  {* libCEC's major version number as string}
  CEC_LIB_VERSION_MAJOR_STR = '6';
  {* libCEC's minor version number}
  CEC_LIB_VERSION_MINOR = 0;
  {* libCEC's minor version number}
  CEC_LIB_VERSION_PATCH = 2;

  {$IFDEF LINUX}
  libcec = 'libcec.so';
  {$ENDIF LINUX}
  {$IFDEF WINDOWS}
  libcec = 'libcec.dll';
  {$ENDIF WINDOWS}

  _PU = '';

function LIBCEC_UINT_TO_VERSION_MAJOR(x: longint): longint;

function LIBCEC_UINT_TO_VERSION_MINOR(x: longint): longint;

function LIBCEC_UINT_TO_VERSION_PATCH(x: longint): longint;

const
  CEC_DEFAULT_PHYSICAL_ADDRESS = $1000;
  CEC_DEFAULT_HDMI_PORT = 1;
  CEC_DEFAULT_BASE_DEVICE = 0;
  CEC_BUTTON_TIMEOUT = 500;
  CEC_DOUBLE_TAP_TIMEOUT_MS = 200;
  CEC_POWER_STATE_REFRESH_TIME = 30000;
  CEC_FW_VERSION_UNKNOWN = $FFFF;
  CEC_FW_BUILD_UNKNOWN = 0;
  CEC_CONNECT_TRIES = 3;
  CEC_PHYSICAL_ADDRESS_TV = 0;
  CEC_MIN_PHYSICAL_ADDRESS = $1000;
  CEC_MAX_PHYSICAL_ADDRESS = $FFFE;
  CEC_INVALID_PHYSICAL_ADDRESS = $FFFF;
  CEC_MIN_VENDORID = 1;
  CEC_MAX_VENDORID = $FFFFFE;
  CEC_INVALID_VENDORID = $FFFFFF;
  CEC_MIN_HDMI_PORTNUMBER = 1;
  CEC_MAX_HDMI_PORTNUMBER = 15;
  CEC_HDMI_PORTNUMBER_NONE = 0;
  CEC_DEFAULT_SETTING_ACTIVATE_SOURCE = 1;
  CEC_DEFAULT_SETTING_POWER_OFF_SHUTDOWN = 1;
  CEC_DEFAULT_SETTING_POWER_OFF_ON_STANDBY = 1;
  CEC_DEFAULT_DEVICE_LANGUAGE = 'eng';
  CEC_DEFAULT_SETTING_AUTODETECT_ADDRESS = 0;
  CEC_DEFAULT_SETTING_GET_SETTINGS_FROM_ROM = 0;
  CEC_DEFAULT_SETTING_CEC_VERSION = $05;
  CEC_DEFAULT_TRANSMIT_RETRY_WAIT = 500;
  CEC_DEFAULT_TRANSMIT_TIMEOUT = 1000;
  CEC_DEFAULT_TRANSMIT_WAIT = 1000;
  CEC_DEFAULT_TRANSMIT_RETRIES = 1;
  CEC_DEFAULT_CONNECT_TIMEOUT = 10000;
  CEC_DEFAULT_CONNECT_RETRY_WAIT = 1000;
  CEC_SERIAL_DEFAULT_BAUDRATE = 38400;
  CEC_CLEAR_INPUT_DEFAULT_WAIT = 1000;
  CEC_ACTIVE_SOURCE_SWITCH_RETRY_TIME_MS = 1000;
  CEC_FORWARD_STANDBY_MIN_INTERVAL = 10000;
  CEC_DEFAULT_COMBO_TIMEOUT_MS = 1000;
  CEC_RPI_VIRTUAL_PATH = 'Raspberry Pi';
  CEC_RPI_VIRTUAL_COM = 'RPI';
  CEC_TDA995x_PATH = '/dev/hdmicec';
  CEC_TDA995x_VIRTUAL_COM = 'CuBox';
  CEC_EXYNOS_PATH = '/dev/CEC';
  CEC_EXYNOS_VIRTUAL_COM = 'Exynos';
  CEC_MAX_DATA_PACKET_SIZE = (16 * 4);
  CEC_LINUX_PATH = '/dev/cec0';
  CEC_LINUX_VIRTUAL_COM = 'Linux';
  CEC_AOCEC_PATH = '/dev/aocec';
  CEC_AOCEC_VIRTUAL_COM = 'AOCEC';
  CEC_IMX_PATH = '/dev/mxc_hdmi_cec';
  CEC_IMX_VIRTUAL_COM = 'i.MX';
  CEC_MIN_LIB_VERSION = 4;
  MSGSTART = $FF;
  MSGEND = $FE;
  MSGESC = $FD;
  ESCOFFSET = 3;
  DOUBLE_TAP_TIMEOUT_UNIT_SIZE = (50);
  CEC_FEATURE_CONFIGURABLE_COMBO_KEY = 1;
  LIBCEC_OSD_NAME_SIZE = (15);

type
  // Forward declarations
  Pcec_log_message = ^cec_log_message;
  Pcec_keypress = ^cec_keypress;
  Pcec_adapter = ^cec_adapter;
  Pcec_adapter_descriptor = ^cec_adapter_descriptor;
  Pcec_datapacket = ^cec_datapacket;
  Pcec_command = ^cec_command;
  Pcec_device_type_list = ^cec_device_type_list;
  Pcec_logical_addresses = ^cec_logical_addresses;
  Plibcec_parameter = ^libcec_parameter;
  Pcec_adapter_stats = ^cec_adapter_stats;
  PICECCallbacks = ^ICECCallbacks;
  Plibcec_configuration = ^libcec_configuration;

  int8_t = UTF8Char;
  int16_t = smallint;
  int32_t = integer;
  int64_t = int64;
  uint8_t = byte;
  uint16_t = word;
  uint32_t = cardinal;
  uint64_t = uint64;

  cec_abort_reason = (
    //! CEC_ABORT_REASON_UNRECOGNIZED_OPCODE
    CEC_ABORT_REASON_UNRECOGNIZED_OPCODE = 0,
    //! CEC_ABORT_REASON_NOT_IN_CORRECT_MODE_TO_RESPOND
    CEC_ABORT_REASON_NOT_IN_CORRECT_MODE_TO_RESPOND = 1,
    //! CEC_ABORT_REASON_CANNOT_PROVIDE_SOURCE
    CEC_ABORT_REASON_CANNOT_PROVIDE_SOURCE = 2,
    //! CEC_ABORT_REASON_INVALID_OPERAND
    CEC_ABORT_REASON_INVALID_OPERAND = 3,
    //! CEC_ABORT_REASON_REFUSED
    CEC_ABORT_REASON_REFUSED = 4);
  Pcec_abort_reason = ^cec_abort_reason;

  cec_analogue_broadcast_type = (
    CEC_ANALOGUE_BROADCAST_TYPE_CABLE = 0,
    CEC_ANALOGUE_BROADCAST_TYPE_SATELLITE = 1,
    CEC_ANALOGUE_BROADCAST_TYPE_TERRESTIAL = 2);
  Pcec_analogue_broadcast_type = ^cec_analogue_broadcast_type;

  cec_audio_rate = (
    CEC_AUDIO_RATE_RATE_CONTROL_OFF = 0,
    CEC_AUDIO_RATE_STANDARD_RATE_100 = 1,
    CEC_AUDIO_RATE_FAST_RATE_MAX_101 = 2,
    CEC_AUDIO_RATE_SLOW_RATE_MIN_99 = 3,
    CEC_AUDIO_RATE_STANDARD_RATE_100_0 = 4,
    CEC_AUDIO_RATE_FAST_RATE_MAX_100_1 = 5,
    CEC_AUDIO_RATE_SLOW_RATE_MIN_99_9 = 6);
  Pcec_audio_rate = ^cec_audio_rate;

  cec_audio_status = (
    CEC_AUDIO_VOLUME_MIN = 0,
    CEC_AUDIO_VOLUME_MAX = 100,
    CEC_AUDIO_VOLUME_STATUS_UNKNOWN = 127,
    CEC_AUDIO_VOLUME_STATUS_MASK = 127,
    CEC_AUDIO_MUTE_STATUS_MASK = 128);

  Pcec_audio_status = ^cec_audio_status;

  cec_boolean = (
    CEC_FALSE = 0,
    CEC_TRUE = 1);
  Pcec_boolean = ^cec_boolean;

  cec_version = (
    CEC_VERSION_UNKNOWN = 0,
    CEC_VERSION_1_2 = 1,
    CEC_VERSION_1_2A = 2,
    CEC_VERSION_1_3 = 3,
    CEC_VERSION_1_3A = 4,
    CEC_VERSION_1_4 = 5,
    CEC_VERSION_2_0 = 6);
  Pcec_version = ^cec_version;

  cec_channel_identifier = (
    CEC_CHANNEL_NUMBER_FORMAT_MASK = -67108864,
    CEC_1_PART_CHANNEL_NUMBER = 67108864,
    CEC_2_PART_CHANNEL_NUMBER = 134217728,
    CEC_MAJOR_CHANNEL_NUMBER_MASK = 67043328,
    CEC_MINOR_CHANNEL_NUMBER_MASK = 65535);
  Pcec_channel_identifier = ^cec_channel_identifier;

  cec_deck_control_mode = (
    CEC_DECK_CONTROL_MODE_SKIP_FORWARD_WIND = 1,
    CEC_DECK_CONTROL_MODE_SKIP_REVERSE_REWIND = 2,
    CEC_DECK_CONTROL_MODE_STOP = 3,
    CEC_DECK_CONTROL_MODE_EJECT = 4);
  Pcec_deck_control_mode = ^cec_deck_control_mode;

  cec_deck_info = (
    CEC_DECK_INFO_PLAY = 17,
    CEC_DECK_INFO_RECORD = 18,
    CEC_DECK_INFO_PLAY_REVERSE = 19,
    CEC_DECK_INFO_STILL = 20,
    CEC_DECK_INFO_SLOW = 21,
    CEC_DECK_INFO_SLOW_REVERSE = 22,
    CEC_DECK_INFO_FAST_FORWARD = 23,
    CEC_DECK_INFO_FAST_REVERSE = 24,
    CEC_DECK_INFO_NO_MEDIA = 25,
    CEC_DECK_INFO_STOP = 26,
    CEC_DECK_INFO_SKIP_FORWARD_WIND = 27,
    CEC_DECK_INFO_SKIP_REVERSE_REWIND = 28,
    CEC_DECK_INFO_INDEX_SEARCH_FORWARD = 29,
    CEC_DECK_INFO_INDEX_SEARCH_REVERSE = 30,
    CEC_DECK_INFO_OTHER_STATUS = 31,
    CEC_DECK_INFO_OTHER_STATUS_LG = 32);
  Pcec_deck_info = ^cec_deck_info;

  cec_device_type = (
    CEC_DEVICE_TYPE_TV = 0,
    CEC_DEVICE_TYPE_RECORDING_DEVICE = 1,
    CEC_DEVICE_TYPE_RESERVED = 2,
    CEC_DEVICE_TYPE_TUNER = 3,
    CEC_DEVICE_TYPE_PLAYBACK_DEVICE = 4,
    CEC_DEVICE_TYPE_AUDIO_SYSTEM = 5);
  Pcec_device_type = ^cec_device_type;

  cec_display_control = (
    CEC_DISPLAY_CONTROL_DISPLAY_FOR_DEFAULT_TIME = 0,
    CEC_DISPLAY_CONTROL_DISPLAY_UNTIL_CLEARED = 64,
    CEC_DISPLAY_CONTROL_CLEAR_PREVIOUS_MESSAGE = 128,
    CEC_DISPLAY_CONTROL_RESERVED_FOR_FUTURE_USE = 192);
  Pcec_display_control = ^cec_display_control;

  cec_external_source_specifier = (
    CEC_EXTERNAL_SOURCE_SPECIFIER_EXTERNAL_PLUG = 4,
    CEC_EXTERNAL_SOURCE_SPECIFIER_EXTERNAL_PHYSICAL_ADDRESS = 5);
  Pcec_external_source_specifier = ^cec_external_source_specifier;

  cec_menu_request_type = (
    CEC_MENU_REQUEST_TYPE_ACTIVATE = 0,
    CEC_MENU_REQUEST_TYPE_DEACTIVATE = 1,
    CEC_MENU_REQUEST_TYPE_QUERY = 2);
  Pcec_menu_request_type = ^cec_menu_request_type;

  cec_menu_state = (
    CEC_MENU_STATE_ACTIVATED = 0,
    CEC_MENU_STATE_DEACTIVATED = 1);
  Pcec_menu_state = ^cec_menu_state;

  cec_play_mode = (
    CEC_PLAY_MODE_PLAY_FORWARD = 36,
    CEC_PLAY_MODE_PLAY_REVERSE = 32,
    CEC_PLAY_MODE_PLAY_STILL = 37,
    CEC_PLAY_MODE_FAST_FORWARD_MIN_SPEED = 5,
    CEC_PLAY_MODE_FAST_FORWARD_MEDIUM_SPEED = 6,
    CEC_PLAY_MODE_FAST_FORWARD_MAX_SPEED = 7,
    CEC_PLAY_MODE_FAST_REVERSE_MIN_SPEED = 9,
    CEC_PLAY_MODE_FAST_REVERSE_MEDIUM_SPEED = 10,
    CEC_PLAY_MODE_FAST_REVERSE_MAX_SPEED = 11,
    CEC_PLAY_MODE_SLOW_FORWARD_MIN_SPEED = 21,
    CEC_PLAY_MODE_SLOW_FORWARD_MEDIUM_SPEED = 22,
    CEC_PLAY_MODE_SLOW_FORWARD_MAX_SPEED = 23,
    CEC_PLAY_MODE_SLOW_REVERSE_MIN_SPEED = 25,
    CEC_PLAY_MODE_SLOW_REVERSE_MEDIUM_SPEED = 26,
    CEC_PLAY_MODE_SLOW_REVERSE_MAX_SPEED = 27);
  Pcec_play_mode = ^cec_play_mode;

  cec_power_status = (
    CEC_POWER_STATUS_ON = 0,
    CEC_POWER_STATUS_STANDBY = 1,
    CEC_POWER_STATUS_IN_TRANSITION_STANDBY_TO_ON = 2,
    CEC_POWER_STATUS_IN_TRANSITION_ON_TO_STANDBY = 3,
    CEC_POWER_STATUS_UNKNOWN = 153);
  Pcec_power_status = ^cec_power_status;

  cec_record_source_type = (
    CEC_RECORD_SOURCE_TYPE_OWN_SOURCE = 1,
    CEC_RECORD_SOURCE_TYPE_DIGITAL_SERVICE = 2,
    CEC_RECORD_SOURCE_TYPE_ANALOGUE_SERVICE = 3,
    CEC_RECORD_SOURCE_TYPE_EXTERNAL_PLUS = 4,
    CEC_RECORD_SOURCE_TYPE_EXTERNAL_PHYSICAL_ADDRESS = 5);
  Pcec_record_source_type = ^cec_record_source_type;

  cec_record_status_info = (
    CEC_RECORD_STATUS_INFO_RECORDING_CURRENTLY_SELECTED_SOURCE = 1,
    CEC_RECORD_STATUS_INFO_RECORDING_DIGITAL_SERVICE = 2,
    CEC_RECORD_STATUS_INFO_RECORDING_ANALOGUE_SERVICE = 3,
    CEC_RECORD_STATUS_INFO_RECORDING_EXTERNAL_INPUT = 4,
    CEC_RECORD_STATUS_INFO_NO_RECORDING_UNABLE_TO_RECORD_DIGITAL_SERVICE = 5,
    CEC_RECORD_STATUS_INFO_NO_RECORDING_UNABLE_TO_RECORD_ANALOGUE_SERVICE = 6,
    CEC_RECORD_STATUS_INFO_NO_RECORDING_UNABLE_TO_SELECT_REQUIRED_SERVICE = 7,
    CEC_RECORD_STATUS_INFO_NO_RECORDING_INVALID_EXTERNAL_PLUG_NUMBER = 9,
    CEC_RECORD_STATUS_INFO_NO_RECORDING_INVALID_EXTERNAL_ADDRESS = 10,
    CEC_RECORD_STATUS_INFO_NO_RECORDING_CA_SYSTEM_NOT_SUPPORTED = 11,
    CEC_RECORD_STATUS_INFO_NO_RECORDING_NO_OR_INSUFFICIENT_ENTITLEMENTS = 12,
    CEC_RECORD_STATUS_INFO_NO_RECORDING_NOT_ALLOWED_TO_COPY_SOURCE = 13,
    CEC_RECORD_STATUS_INFO_NO_RECORDING_NO_FURTHER_COPIES_ALLOWED = 14,
    CEC_RECORD_STATUS_INFO_NO_RECORDING_NO_MEDIA = 16,
    CEC_RECORD_STATUS_INFO_NO_RECORDING_PLAYING = 17,
    CEC_RECORD_STATUS_INFO_NO_RECORDING_ALREADY_RECORDING = 18,
    CEC_RECORD_STATUS_INFO_NO_RECORDING_MEDIA_PROTECTED = 19,
    CEC_RECORD_STATUS_INFO_NO_RECORDING_NO_SOURCE_SIGNAL = 20,
    CEC_RECORD_STATUS_INFO_NO_RECORDING_MEDIA_PROBLEM = 21,
    CEC_RECORD_STATUS_INFO_NO_RECORDING_NOT_ENOUGH_SPACE_AVAILABLE = 22,
    CEC_RECORD_STATUS_INFO_NO_RECORDING_PARENTAL_LOCK_ON = 23,
    CEC_RECORD_STATUS_INFO_RECORDING_TERMINATED_NORMALLY = 26,
    CEC_RECORD_STATUS_INFO_RECORDING_HAS_ALREADY_TERMINATED = 27,
    CEC_RECORD_STATUS_INFO_NO_RECORDING_OTHER_REASON = 31);
  Pcec_record_status_info = ^cec_record_status_info;

  cec_recording_sequence = (
    CEC_RECORDING_SEQUENCE_SUNDAY = 1,
    CEC_RECORDING_SEQUENCE_MONDAY = 2,
    CEC_RECORDING_SEQUENCE_TUESDAY = 4,
    CEC_RECORDING_SEQUENCE_WEDNESDAY = 8,
    CEC_RECORDING_SEQUENCE_THURSDAY = 16,
    CEC_RECORDING_SEQUENCE_FRIDAY = 32,
    CEC_RECORDING_SEQUENCE_SATURDAY = 64,
    CEC_RECORDING_SEQUENCE_ONCE_ONLY = 0);
  Pcec_recording_sequence = ^cec_recording_sequence;

  cec_status_request = (
    CEC_STATUS_REQUEST_ON = 1,
    CEC_STATUS_REQUEST_OFF = 2,
    CEC_STATUS_REQUEST_ONCE = 3);
  Pcec_status_request = ^cec_status_request;

  cec_system_audio_status = (
    CEC_SYSTEM_AUDIO_STATUS_OFF = 0,
    CEC_SYSTEM_AUDIO_STATUS_ON = 1);
  Pcec_system_audio_status = ^cec_system_audio_status;

  cec_timer_cleared_status_data = (
    CEC_TIMER_CLEARED_STATUS_DATA_TIMER_NOT_CLEARED_RECORDING = 0,
    CEC_TIMER_CLEARED_STATUS_DATA_TIMER_NOT_CLEARED_NO_MATCHING = 1,
    CEC_TIMER_CLEARED_STATUS_DATA_TIMER_NOT_CLEARED_NO_INF0_AVAILABLE = 2,
    CEC_TIMER_CLEARED_STATUS_DATA_TIMER_CLEARED = 128);
  Pcec_timer_cleared_status_data = ^cec_timer_cleared_status_data;

  cec_timer_overlap_warning = (
    CEC_TIMER_OVERLAP_WARNING_NO_OVERLAP = 0,
    CEC_TIMER_OVERLAP_WARNING_TIMER_BLOCKS_OVERLAP = 1);
  Pcec_timer_overlap_warning = ^cec_timer_overlap_warning;

  cec_media_info = (
    CEC_MEDIA_INFO_MEDIA_PRESENT_AND_NOT_PROTECTED = 0,
    CEC_MEDIA_INFO_MEDIA_PRESENT_BUT_PROTECTED = 1,
    CEC_MEDIA_INFO_MEDIA_NOT_PRESENT = 2,
    CEC_MEDIA_INFO_FUTURE_USE = 3);
  Pcec_media_info = ^cec_media_info;

  cec_programmed_indicator = (
    CEC_PROGRAMMED_INDICATOR_NOT_PROGRAMMED = 0,
    CEC_PROGRAMMED_INDICATOR_PROGRAMMED = 1);
  Pcec_programmed_indicator = ^cec_programmed_indicator;

  cec_programmed_info = (
    CEC_PROGRAMMED_INFO_FUTURE_USE = 0,
    CEC_PROGRAMMED_INFO_ENOUGH_SPACE_AVAILABLE_FOR_RECORDING = 8,
    CEC_PROGRAMMED_INFO_NOT_ENOUGH_SPACE_AVAILABLE_FOR_RECORDING = 9,
    CEC_PROGRAMMED_INFO_MAY_NOT_BE_ENOUGH_SPACE_AVAILABLE = 11,
    CEC_PROGRAMMED_INFO_NO_MEDIA_INFO_AVAILABLE = 10);
  Pcec_programmed_info = ^cec_programmed_info;

  cec_not_programmed_error_info = (
    CEC_NOT_PROGRAMMED_ERROR_INFO_FUTURE_USE = 0,
    CEC_NOT_PROGRAMMED_ERROR_INFO_NO_FREE_TIMER_AVAILABLE = 1,
    CEC_NOT_PROGRAMMED_ERROR_INFO_DATE_OUT_OF_RANGE = 2,
    CEC_NOT_PROGRAMMED_ERROR_INFO_RECORDING_SEQUENCE_ERROR = 3,
    CEC_NOT_PROGRAMMED_ERROR_INFO_INVALID_EXTERNAL_PLUG_NUMBER = 4,
    CEC_NOT_PROGRAMMED_ERROR_INFO_INVALID_EXTERNAL_PHYSICAL_ADDRESS = 5,
    CEC_NOT_PROGRAMMED_ERROR_INFO_CA_SYSTEM_NOT_SUPPORTED = 6,
    CEC_NOT_PROGRAMMED_ERROR_INFO_NO_OR_INSUFFICIENT_CA_ENTITLEMENTS = 7,
    CEC_NOT_PROGRAMMED_ERROR_INFO_DOES_NOT_SUPPORT_RESOLUTION = 8,
    CEC_NOT_PROGRAMMED_ERROR_INFO_PARENTAL_LOCK_ON = 9,
    CEC_NOT_PROGRAMMED_ERROR_INFO_CLOCK_FAILURE = 10,
    CEC_NOT_PROGRAMMED_ERROR_INFO_RESERVED_FOR_FUTURE_USE_START = 11,
    CEC_NOT_PROGRAMMED_ERROR_INFO_RESERVED_FOR_FUTURE_USE_END = 13,
    CEC_NOT_PROGRAMMED_ERROR_INFO_DUPLICATE_ALREADY_PROGRAMMED = 14);
  Pcec_not_programmed_error_info = ^cec_not_programmed_error_info;

  cec_recording_flag = (
    CEC_RECORDING_FLAG_NOT_BEING_USED_FOR_RECORDING = 0,
    CEC_RECORDING_FLAG_BEING_USED_FOR_RECORDING = 1);
  Pcec_recording_flag = ^cec_recording_flag;

  cec_tuner_display_info = (
    CEC_TUNER_DISPLAY_INFO_DISPLAYING_DIGITAL_TUNER = 0,
    CEC_TUNER_DISPLAY_INFO_NOT_DISPLAYING_TUNER = 1,
    CEC_TUNER_DISPLAY_INFO_DISPLAYING_ANALOGUE_TUNER = 2);
  Pcec_tuner_display_info = ^cec_tuner_display_info;

  cec_broadcast_system = (
    CEC_BROADCAST_SYSTEM_PAL_B_G = 0,
    CEC_BROADCAST_SYSTEM_SECAM_L1 = 1,
    CEC_BROADCAST_SYSTEM_PAL_M = 2,
    CEC_BROADCAST_SYSTEM_NTSC_M = 3,
    CEC_BROADCAST_SYSTEM_PAL_I = 4,
    CEC_BROADCAST_SYSTEM_SECAM_DK = 5,
    CEC_BROADCAST_SYSTEM_SECAM_B_G = 6,
    CEC_BROADCAST_SYSTEM_SECAM_L2 = 7,
    CEC_BROADCAST_SYSTEM_PAL_DK = 8,
    CEC_BROADCAST_SYSTEM_OTHER_SYSTEM = 30);
  Pcec_broadcast_system = ^cec_broadcast_system;

  cec_user_control_code = (
    CEC_USER_CONTROL_CODE_SELECT = 0,
    CEC_USER_CONTROL_CODE_UP = 1,
    CEC_USER_CONTROL_CODE_DOWN = 2,
    CEC_USER_CONTROL_CODE_LEFT = 3,
    CEC_USER_CONTROL_CODE_RIGHT = 4,
    CEC_USER_CONTROL_CODE_RIGHT_UP = 5,
    CEC_USER_CONTROL_CODE_RIGHT_DOWN = 6,
    CEC_USER_CONTROL_CODE_LEFT_UP = 7,
    CEC_USER_CONTROL_CODE_LEFT_DOWN = 8,
    CEC_USER_CONTROL_CODE_ROOT_MENU = 9,
    CEC_USER_CONTROL_CODE_SETUP_MENU = 10,
    CEC_USER_CONTROL_CODE_CONTENTS_MENU = 11,
    CEC_USER_CONTROL_CODE_FAVORITE_MENU = 12,
    CEC_USER_CONTROL_CODE_EXIT = 13,
    CEC_USER_CONTROL_CODE_TOP_MENU = 16,
    CEC_USER_CONTROL_CODE_DVD_MENU = 17,
    CEC_USER_CONTROL_CODE_NUMBER_ENTRY_MODE = 29,
    CEC_USER_CONTROL_CODE_NUMBER11 = 30,
    CEC_USER_CONTROL_CODE_NUMBER12 = 31,
    CEC_USER_CONTROL_CODE_NUMBER0 = 32,
    CEC_USER_CONTROL_CODE_NUMBER1 = 33,
    CEC_USER_CONTROL_CODE_NUMBER2 = 34,
    CEC_USER_CONTROL_CODE_NUMBER3 = 35,
    CEC_USER_CONTROL_CODE_NUMBER4 = 36,
    CEC_USER_CONTROL_CODE_NUMBER5 = 37,
    CEC_USER_CONTROL_CODE_NUMBER6 = 38,
    CEC_USER_CONTROL_CODE_NUMBER7 = 39,
    CEC_USER_CONTROL_CODE_NUMBER8 = 40,
    CEC_USER_CONTROL_CODE_NUMBER9 = 41,
    CEC_USER_CONTROL_CODE_DOT = 42,
    CEC_USER_CONTROL_CODE_ENTER = 43,
    CEC_USER_CONTROL_CODE_CLEAR = 44,
    CEC_USER_CONTROL_CODE_NEXT_FAVORITE = 47,
    CEC_USER_CONTROL_CODE_CHANNEL_UP = 48,
    CEC_USER_CONTROL_CODE_CHANNEL_DOWN = 49,
    CEC_USER_CONTROL_CODE_PREVIOUS_CHANNEL = 50,
    CEC_USER_CONTROL_CODE_SOUND_SELECT = 51,
    CEC_USER_CONTROL_CODE_INPUT_SELECT = 52,
    CEC_USER_CONTROL_CODE_DISPLAY_INFORMATION = 53,
    CEC_USER_CONTROL_CODE_HELP = 54,
    CEC_USER_CONTROL_CODE_PAGE_UP = 55,
    CEC_USER_CONTROL_CODE_PAGE_DOWN = 56,
    CEC_USER_CONTROL_CODE_POWER = 64,
    CEC_USER_CONTROL_CODE_VOLUME_UP = 65,
    CEC_USER_CONTROL_CODE_VOLUME_DOWN = 66,
    CEC_USER_CONTROL_CODE_MUTE = 67,
    CEC_USER_CONTROL_CODE_PLAY = 68,
    CEC_USER_CONTROL_CODE_STOP = 69,
    CEC_USER_CONTROL_CODE_PAUSE = 70,
    CEC_USER_CONTROL_CODE_RECORD = 71,
    CEC_USER_CONTROL_CODE_REWIND = 72,
    CEC_USER_CONTROL_CODE_FAST_FORWARD = 73,
    CEC_USER_CONTROL_CODE_EJECT = 74,
    CEC_USER_CONTROL_CODE_FORWARD = 75,
    CEC_USER_CONTROL_CODE_BACKWARD = 76,
    CEC_USER_CONTROL_CODE_STOP_RECORD = 77,
    CEC_USER_CONTROL_CODE_PAUSE_RECORD = 78,
    CEC_USER_CONTROL_CODE_ANGLE = 80,
    CEC_USER_CONTROL_CODE_SUB_PICTURE = 81,
    CEC_USER_CONTROL_CODE_VIDEO_ON_DEMAND = 82,
    CEC_USER_CONTROL_CODE_ELECTRONIC_PROGRAM_GUIDE = 83,
    CEC_USER_CONTROL_CODE_TIMER_PROGRAMMING = 84,
    CEC_USER_CONTROL_CODE_INITIAL_CONFIGURATION = 85,
    CEC_USER_CONTROL_CODE_SELECT_BROADCAST_TYPE = 86,
    CEC_USER_CONTROL_CODE_SELECT_SOUND_PRESENTATION = 87,
    CEC_USER_CONTROL_CODE_PLAY_FUNCTION = 96,
    CEC_USER_CONTROL_CODE_PAUSE_PLAY_FUNCTION = 97,
    CEC_USER_CONTROL_CODE_RECORD_FUNCTION = 98,
    CEC_USER_CONTROL_CODE_PAUSE_RECORD_FUNCTION = 99,
    CEC_USER_CONTROL_CODE_STOP_FUNCTION = 100,
    CEC_USER_CONTROL_CODE_MUTE_FUNCTION = 101,
    CEC_USER_CONTROL_CODE_RESTORE_VOLUME_FUNCTION = 102,
    CEC_USER_CONTROL_CODE_TUNE_FUNCTION = 103,
    CEC_USER_CONTROL_CODE_SELECT_MEDIA_FUNCTION = 104,
    CEC_USER_CONTROL_CODE_SELECT_AV_INPUT_FUNCTION = 105,
    CEC_USER_CONTROL_CODE_SELECT_AUDIO_INPUT_FUNCTION = 106,
    CEC_USER_CONTROL_CODE_POWER_TOGGLE_FUNCTION = 107,
    CEC_USER_CONTROL_CODE_POWER_OFF_FUNCTION = 108,
    CEC_USER_CONTROL_CODE_POWER_ON_FUNCTION = 109,
    CEC_USER_CONTROL_CODE_F1_BLUE = 113,
    CEC_USER_CONTROL_CODE_F2_RED = 114,
    CEC_USER_CONTROL_CODE_F3_GREEN = 115,
    CEC_USER_CONTROL_CODE_F4_YELLOW = 116,
    CEC_USER_CONTROL_CODE_F5 = 117,
    CEC_USER_CONTROL_CODE_DATA = 118,
    CEC_USER_CONTROL_CODE_AN_RETURN = 145,
    CEC_USER_CONTROL_CODE_AN_CHANNELS_LIST = 150,
    CEC_USER_CONTROL_CODE_MAX = 150,
    CEC_USER_CONTROL_CODE_UNKNOWN = 255);
  Pcec_user_control_code = ^cec_user_control_code;

  cec_logical_address = (
    CECDEVICE_UNKNOWN = -1,
    CECDEVICE_TV = 0,
    CECDEVICE_RECORDINGDEVICE1 = 1,
    CECDEVICE_RECORDINGDEVICE2 = 2,
    CECDEVICE_TUNER1 = 3,
    CECDEVICE_PLAYBACKDEVICE1 = 4,
    CECDEVICE_AUDIOSYSTEM = 5,
    CECDEVICE_TUNER2 = 6,
    CECDEVICE_TUNER3 = 7,
    CECDEVICE_PLAYBACKDEVICE2 = 8,
    CECDEVICE_RECORDINGDEVICE3 = 9,
    CECDEVICE_TUNER4 = 10,
    CECDEVICE_PLAYBACKDEVICE3 = 11,
    CECDEVICE_RESERVED1 = 12,
    CECDEVICE_RESERVED2 = 13,
    CECDEVICE_FREEUSE = 14,
    CECDEVICE_UNREGISTERED = 15,
    CECDEVICE_BROADCAST = 15);
  Pcec_logical_address = ^cec_logical_address;

  cec_opcode = (
    CEC_OPCODE_ACTIVE_SOURCE = 130,
    CEC_OPCODE_IMAGE_VIEW_ON = 4,
    CEC_OPCODE_TEXT_VIEW_ON = 13,
    CEC_OPCODE_INACTIVE_SOURCE = 157,
    CEC_OPCODE_REQUEST_ACTIVE_SOURCE = 133,
    CEC_OPCODE_ROUTING_CHANGE = 128,
    CEC_OPCODE_ROUTING_INFORMATION = 129,
    CEC_OPCODE_SET_STREAM_PATH = 134,
    CEC_OPCODE_STANDBY = 54,
    CEC_OPCODE_RECORD_OFF = 11,
    CEC_OPCODE_RECORD_ON = 9,
    CEC_OPCODE_RECORD_STATUS = 10,
    CEC_OPCODE_RECORD_TV_SCREEN = 15,
    CEC_OPCODE_CLEAR_ANALOGUE_TIMER = 51,
    CEC_OPCODE_CLEAR_DIGITAL_TIMER = 153,
    CEC_OPCODE_CLEAR_EXTERNAL_TIMER = 161,
    CEC_OPCODE_SET_ANALOGUE_TIMER = 52,
    CEC_OPCODE_SET_DIGITAL_TIMER = 151,
    CEC_OPCODE_SET_EXTERNAL_TIMER = 162,
    CEC_OPCODE_SET_TIMER_PROGRAM_TITLE = 103,
    CEC_OPCODE_TIMER_CLEARED_STATUS = 67,
    CEC_OPCODE_TIMER_STATUS = 53,
    CEC_OPCODE_CEC_VERSION = 158,
    CEC_OPCODE_GET_CEC_VERSION = 159,
    CEC_OPCODE_GIVE_PHYSICAL_ADDRESS = 131,
    CEC_OPCODE_GET_MENU_LANGUAGE = 145,
    CEC_OPCODE_REPORT_PHYSICAL_ADDRESS = 132,
    CEC_OPCODE_SET_MENU_LANGUAGE = 50,
    CEC_OPCODE_DECK_CONTROL = 66,
    CEC_OPCODE_DECK_STATUS = 27,
    CEC_OPCODE_GIVE_DECK_STATUS = 26,
    CEC_OPCODE_PLAY = 65,
    CEC_OPCODE_GIVE_TUNER_DEVICE_STATUS = 8,
    CEC_OPCODE_SELECT_ANALOGUE_SERVICE = 146,
    CEC_OPCODE_SELECT_DIGITAL_SERVICE = 147,
    CEC_OPCODE_TUNER_DEVICE_STATUS = 7,
    CEC_OPCODE_TUNER_STEP_DECREMENT = 6,
    CEC_OPCODE_TUNER_STEP_INCREMENT = 5,
    CEC_OPCODE_DEVICE_VENDOR_ID = 135,
    CEC_OPCODE_GIVE_DEVICE_VENDOR_ID = 140,
    CEC_OPCODE_VENDOR_COMMAND = 137,
    CEC_OPCODE_VENDOR_COMMAND_WITH_ID = 160,
    CEC_OPCODE_VENDOR_REMOTE_BUTTON_DOWN = 138,
    CEC_OPCODE_VENDOR_REMOTE_BUTTON_UP = 139,
    CEC_OPCODE_SET_OSD_STRING = 100,
    CEC_OPCODE_GIVE_OSD_NAME = 70,
    CEC_OPCODE_SET_OSD_NAME = 71,
    CEC_OPCODE_MENU_REQUEST = 141,
    CEC_OPCODE_MENU_STATUS = 142,
    CEC_OPCODE_USER_CONTROL_PRESSED = 68,
    CEC_OPCODE_USER_CONTROL_RELEASE = 69,
    CEC_OPCODE_GIVE_DEVICE_POWER_STATUS = 143,
    CEC_OPCODE_REPORT_POWER_STATUS = 144,
    CEC_OPCODE_FEATURE_ABORT = 0,
    CEC_OPCODE_ABORT = 255,
    CEC_OPCODE_GIVE_AUDIO_STATUS = 113,
    CEC_OPCODE_GIVE_SYSTEM_AUDIO_MODE_STATUS = 125,
    CEC_OPCODE_REPORT_AUDIO_STATUS = 122,
    CEC_OPCODE_SET_SYSTEM_AUDIO_MODE = 114,
    CEC_OPCODE_SYSTEM_AUDIO_MODE_REQUEST = 112,
    CEC_OPCODE_SYSTEM_AUDIO_MODE_STATUS = 126,
    CEC_OPCODE_SET_AUDIO_RATE = 154,
    CEC_OPCODE_REPORT_SHORT_AUDIO_DESCRIPTORS = 163,
    CEC_OPCODE_REQUEST_SHORT_AUDIO_DESCRIPTORS = 164,
    CEC_OPCODE_START_ARC = 192,
    CEC_OPCODE_REPORT_ARC_STARTED = 193,
    CEC_OPCODE_REPORT_ARC_ENDED = 194,
    CEC_OPCODE_REQUEST_ARC_START = 195,
    CEC_OPCODE_REQUEST_ARC_END = 196,
    CEC_OPCODE_END_ARC = 197,
    CEC_OPCODE_CDC = 248,
    CEC_OPCODE_NONE = 253);
  Pcec_opcode = ^cec_opcode;

  cec_log_level = (
    CEC_LOG_ERROR = 1,
    CEC_LOG_WARNING = 2,
    CEC_LOG_NOTICE = 4,
    CEC_LOG_TRAFFIC = 8,
    CEC_LOG_DEBUG = 16,
    CEC_LOG_ALL = 31);
  Pcec_log_level = ^cec_log_level;

  cec_bus_device_status = (
    CEC_DEVICE_STATUS_UNKNOWN = 0,
    CEC_DEVICE_STATUS_PRESENT = 1,
    CEC_DEVICE_STATUS_NOT_PRESENT = 2,
    CEC_DEVICE_STATUS_HANDLED_BY_LIBCEC = 3);
  Pcec_bus_device_status = ^cec_bus_device_status;

  cec_vendor_id = (
    CEC_VENDOR_TOSHIBA = 57,
    CEC_VENDOR_SAMSUNG = 240,
    CEC_VENDOR_DENON = 1485,
    CEC_VENDOR_MARANTZ = 1656,
    CEC_VENDOR_LOEWE = 2434,
    CEC_VENDOR_ONKYO = 2480,
    CEC_VENDOR_MEDION = 3256,
    CEC_VENDOR_TOSHIBA2 = 3303,
    CEC_VENDOR_APPLE = 4346,
    CEC_VENDOR_PULSE_EIGHT = 5506,
    CEC_VENDOR_HARMAN_KARDON2 = 6480,
    CEC_VENDOR_GOOGLE = 6673,
    CEC_VENDOR_AKAI = 8391,
    CEC_VENDOR_AOC = 9319,
    CEC_VENDOR_PANASONIC = 32837,
    CEC_VENDOR_PHILIPS = 36926,
    CEC_VENDOR_DAEWOO = 36947,
    CEC_VENDOR_YAMAHA = 41182,
    CEC_VENDOR_GRUNDIG = 53461,
    CEC_VENDOR_PIONEER = 57398,
    CEC_VENDOR_LG = 57489,
    CEC_VENDOR_SHARP = 524319,
    CEC_VENDOR_SONY = 524358,
    CEC_VENDOR_BROADCOM = 1622150,
    CEC_VENDOR_SHARP2 = 5458000,
    CEC_VENDOR_VIZIO = 7042157,
    CEC_VENDOR_BENQ = 8414697,
    CEC_VENDOR_HARMAN_KARDON = 10249310,
    CEC_VENDOR_UNKNOWN = 0);
  Pcec_vendor_id = ^cec_vendor_id;

  cec_adapter_type = (
    ADAPTERTYPE_UNKNOWN = 0,
    ADAPTERTYPE_P8_EXTERNAL = 1,
    ADAPTERTYPE_P8_DAUGHTERBOARD = 2,
    ADAPTERTYPE_RPI = 256,
    ADAPTERTYPE_TDA995x = 512,
    ADAPTERTYPE_EXYNOS = 768,
    ADAPTERTYPE_LINUX = 1024,
    ADAPTERTYPE_AOCEC = 1280,
    ADAPTERTYPE_IMX = 1536);
  Pcec_adapter_type = ^cec_adapter_type;

  (** force exporting through swig *)
  libcec_version = (
    LIBCEC_VERSION_CURRENT = 393218);
  Plibcec_version = ^libcec_version;
  cec_menu_language = array [0..3] of UTF8Char;
  cec_osd_name = array [0..13] of UTF8Char;

  cec_log_message = record
    (** the actual message, valid until returning from the log callback *)
    &message: PUTF8Char;
    (** log level of the message *)
    level: cec_log_level;
    (** the timestamp of this message *)
    time: int64;
  end;

  cec_keypress = record
    (** the keycode *)
    keycode: cec_user_control_code;
    (** the duration of the keypress *)
    duration: cardinal;
  end;

  cec_adapter = record
    (** the path to the com port *)
    path: array [0..1023] of UTF8Char;
    (** the name of the com port *)
    comm: array [0..1023] of UTF8Char;
  end;

  cec_adapter_descriptor = record
    (** the path to the com port *)
    strComPath: array [0..1023] of UTF8Char;
    (** the name of the com port *)
    strComName: array [0..1023] of UTF8Char;
    iVendorId: uint16;
    iProductId: uint16;
    iFirmwareVersion: uint16;
    iPhysicalAddress: uint16;
    iFirmwareBuildDate: uint32;
    adapterType: cec_adapter_type;
  end;

  cec_datapacket = record
    (** the actual data *)
    Data: array [0..63] of uint8;
    (** the size of the data *)
    size: uint8;
  end;

  cec_command = record
    (** the logical address of the initiator of this message *)
    initiator: cec_logical_address;
    (** the logical address of the destination of this message *)
    destination: cec_logical_address;
    (** 1 when the ACK bit is set, 0 otherwise *)
    ack: int8;
    (** 1 when the EOM bit is set, 0 otherwise *)
    eom: int8;
    (** the opcode of this message *)
    opcode: cec_opcode;
    (** the parameters attached to this message *)
    parameters: cec_datapacket;
    (** 1 when an opcode is set, 0 otherwise (POLL message) *)
    opcode_set: int8;
    (** the timeout to use in ms *)
    transmit_timeout: int32;
  end;

  cec_device_type_list = record
    (** the list of device types *)
    types: array [0..4] of cec_device_type;
  end;

  cec_logical_addresses = record
    (** the primary logical address to use *)
    primary: cec_logical_address;
    (** the list of addresses *)
    addresses: array [0..15] of integer;
  end;

  libcec_alert = (
    CEC_ALERT_SERVICE_DEVICE = 0,
    CEC_ALERT_CONNECTION_LOST = 1,
    CEC_ALERT_PERMISSION_ERROR = 2,
    CEC_ALERT_PORT_BUSY = 3,
    CEC_ALERT_PHYSICAL_ADDRESS_ERROR = 4,
    CEC_ALERT_TV_POLL_FAILED = 5);
  Plibcec_alert = ^libcec_alert;

  libcec_parameter_type = (
    CEC_PARAMETER_TYPE_STRING = 0,
    CEC_PARAMETER_TYPE_UNKOWN = 1);
  Plibcec_parameter_type = ^libcec_parameter_type;

  libcec_parameter = record
    (** the type of this parameter *)
    paramType: libcec_parameter_type;
    (** the value of this parameter *)
    paramData: Pointer;
  end;

  cec_adapter_stats = record
    tx_ack: cardinal;
    tx_nack: cardinal;
    tx_error: cardinal;
    rx_total: cardinal;
    rx_error: cardinal;
  end;

  ICECCallbacks = record
    (*!
     * @brief Transfer a log message from libCEC to the client.
     * @param cbparam             Callback parameter provided when the callbacks were set up
     * @param message             The message to transfer.
     *)
    logMessage: procedure(cbparam: Pointer; const &message: Pcec_log_message); cdecl;
    (*!
     * @brief Transfer a keypress from libCEC to the client.
     * @param cbparam             Callback parameter provided when the callbacks were set up
     * @param key                 The keypress to transfer.
     *)
    keyPress: procedure(cbparam: Pointer; const key: Pcec_keypress); cdecl;
    (*!
     * @brief Transfer a CEC command from libCEC to the client.
     * @param cbparam             Callback parameter provided when the callbacks were set up
     * @param command             The command to transfer.
     *)
    commandReceived: procedure(cbparam: Pointer; const command: Pcec_command); cdecl;
    (*!
     * @brief Transfer a changed configuration from libCEC to the client
     * @param cbparam             Callback parameter provided when the callbacks were set up
     * @param configuration       The configuration to transfer
     *)
    configurationChanged: procedure(cbparam: Pointer; const configuration: Plibcec_configuration); cdecl;
    (*!
     * @brief Transfer a libcec alert message from libCEC to the client
     * @param cbparam             Callback parameter provided when the callbacks were set up
     * @param alert               The alert type transfer.
     * @param data                Misc. additional information.
     *)
    alert: procedure(cbparam: Pointer; const alert: libcec_alert; const param: libcec_parameter); cdecl;
    (*!
     * @brief Transfer a menu state change to the client.
     * Transfer a menu state change to the client. If the command returns 1, then the change will be processed by
     * the busdevice. If 0, then the state of the busdevice won't be changed, and will always be kept 'activated',
     * @warning CEC does not allow the player to suppress the menu state change on the TV, so the menu on the TV will always be displayed, whatever the return value of this method is.
     * so keypresses are always routed.
     * @param cbparam             Callback parameter provided when the callbacks were set up
     * @param state               The new value.
     *
     * @return 1 if libCEC should use this new value, 0 otherwise.
     *)
    menuStateChanged: function(cbparam: Pointer; const state: cec_menu_state): integer; cdecl;
    (*!
     * @brief Called when a source that's handled by this client is activated.
     * @param cbparam             Callback parameter provided when the callbacks were set up
     * @param logicalAddress      The address that was just activated.
     * @param bActivated          1 if activated, 0 when deactivated.
     *)
    sourceActivated: procedure(cbParam: Pointer; const logicalAddress: cec_logical_address; const bActivated: uint8); cdecl;
  end;

  libcec_configuration = record
    (*! the version of the client that is connecting *)
    clientVersion: uint32;
    (*! the device name to use on the CEC bus, name + 0 terminator *)
    strDeviceName: array [0..14] of UTF8Char;
    (*! the device type(s) to use on the CEC bus for libCEC *)
    deviceTypes: cec_device_type_list;
    (*! (read only) set to 1 by libCEC when the physical address was autodetected *)
    bAutodetectAddress: uint8;
    (*! the physical address of the CEC adapter *)
    iPhysicalAddress: uint16;
    (*! the logical address of the device to which the adapter is connected. only used when iPhysicalAddress = 0 or when the adapter doesn't support autodetection *)
    baseDevice: cec_logical_address;
    (*! the HDMI port to which the adapter is connected. only used when iPhysicalAddress = 0 or when the adapter doesn't support autodetection *)
    iHDMIPort: uint8;
    (*! override the vendor ID of the TV. leave this untouched to autodetect *)
    tvVendor: uint32;
    (*! list of devices to wake when initialising libCEC or when calling PowerOnDevices() without any parameter. *)
    wakeDevices: cec_logical_addresses;
    (*! list of devices to power off when calling StandbyDevices() without any parameter. *)
    powerOffDevices: cec_logical_addresses;
    (*! the version number of the server. read-only *)
    serverVersion: uint32;
    (*! true to get the settings from the ROM (if set, and a v2 ROM is present), false to use these settings. *)
    bGetSettingsFromROM: uint8;
    (*! make libCEC the active source on the bus when starting the player application *)
    bActivateSource: uint8;
    (*! put this PC in standby mode when the TV is switched off. only used when bShutdownOnStandby = 0  *)
    bPowerOffOnStandby: uint8;
    (*! the object to pass along with a call of the callback methods. NULL to ignore *)
    callbackParam: Pointer;
    (*! the callback methods to use. set this to NULL when not using callbacks *)
    callbacks: PICECCallbacks;
    (*! (read-only) the current logical addresses. added in 1.5.3 *)
    logicalAddresses: cec_logical_addresses;
    (*! (read-only) the firmware version of the adapter. added in 1.6.0 *)
    iFirmwareVersion: uint16;
    (*! the menu language used by the client. 3 character ISO 639-2 country code. see http://http://www.loc.gov/standards/iso639-2/ added in 1.6.2 *)
    strDeviceLanguage: array [0..2] of UTF8Char;
    (*! (read-only) the build date of the firmware, in seconds since epoch. if not available, this value will be set to 0. added in 1.6.2 *)
    iFirmwareBuildDate: uint32;
    (*! won't allocate a CCECClient when starting the connection when set (same as monitor mode). added in 1.6.3 *)
    bMonitorOnly: uint8;
    (*! CEC spec version to use by libCEC. defaults to v1.4. added in 1.8.0 *)
    cecVersion: cec_version;
    (*! type of the CEC adapter that we're connected to. added in 1.8.2 *)
    adapterType: cec_adapter_type;
    (*! key code that initiates combo keys. defaults to CEC_USER_CONTROL_CODE_STOP. CEC_USER_CONTROL_CODE_UNKNOWN to disable. added in 2.0.5 *)
    comboKey: cec_user_control_code;
    (*! timeout until the combo key is sent as normal keypress *)
    iComboKeyTimeoutMs: uint32;
    (*! rate at which buttons autorepeat. 0 means rely on CEC device *)
    iButtonRepeatRateMs: uint32;
    (*! duration after last update until a button is considered released *)
    iButtonReleaseDelayMs: uint32;
    (*! prevent double taps within this timeout. defaults to 200ms. added in 4.0.0 *)
    iDoubleTapTimeoutMs: uint32;
    (*! set to 1 to automatically waking an AVR when the source is activated. added in 4.0.0 *)
    bAutoWakeAVR: uint8;
    (*! set to 1 and save eeprom config to wake the tv when usb is powered. added in 5.0.0 / fw v9 *)
    bAutoPowerOn: uint8;
  end;

  libcec_connection_t = Pointer;

var
  libcec_initialise: function(configuration: Plibcec_configuration): libcec_connection_t; cdecl;
  libcec_destroy: procedure(connection: libcec_connection_t); cdecl;
  libcec_open: function(connection: libcec_connection_t; const strPort: PUTF8Char; iTimeout: uint32): integer; cdecl;
  libcec_close: procedure(connection: libcec_connection_t); cdecl;
  libcec_clear_configuration: procedure(configuration: Plibcec_configuration); cdecl;
  libcec_find_adapters: function(connection: libcec_connection_t; deviceList: Pcec_adapter; iBufSize: uint8;
  const strDevicePath: PUTF8Char): int8; cdecl;
  libcec_init_video_standalone: procedure(connection: libcec_connection_t); cdecl;

  {

function libcec_initialise(configuration: Plibcec_configuration): libcec_connection_t; cdecl;
  external libcec Name _PU + 'libcec_initialise';

procedure libcec_destroy(connection: libcec_connection_t); cdecl; external libcec Name _PU + 'libcec_destroy';

function libcec_open(connection: libcec_connection_t; const strPort: PUTF8Char; iTimeout: uint32): integer;
  cdecl; external libcec Name _PU + 'libcec_open';

procedure libcec_close(connection: libcec_connection_t); cdecl; external libcec Name _PU + 'libcec_close';

procedure libcec_clear_configuration(configuration: Plibcec_configuration); cdecl;
  external libcec Name _PU + 'libcec_clear_configuration';

function libcec_set_callbacks(connection: libcec_connection_t; callbacks: PICECCallbacks; cbParam: Pointer): integer;
  cdecl; external libcec Name _PU + 'libcec_set_callbacks';

function libcec_disabled_callbacks(connection: libcec_connection_t): integer;
  cdecl; external libcec Name _PU + 'libcec_disabled_callbacks';

function libcec_find_adapters(connection: libcec_connection_t; deviceList: Pcec_adapter; iBufSize: uint8;
  const strDevicePath: PUTF8Char): int8; cdecl; external libcec Name _PU + 'libcec_find_adapters';

function libcec_ping_adapters(connection: libcec_connection_t): integer; cdecl; external libcec Name _PU + 'libcec_ping_adapters';

function libcec_start_bootloader(connection: libcec_connection_t): integer;
  cdecl; external libcec Name _PU + 'libcec_start_bootloader';

function libcec_power_on_devices(connection: libcec_connection_t; address: cec_logical_address): integer;
  cdecl; external libcec Name _PU + 'libcec_power_on_devices';

function libcec_standby_devices(connection: libcec_connection_t; address: cec_logical_address): integer;
  cdecl; external libcec Name _PU + 'libcec_standby_devices';

function libcec_set_active_source(connection: libcec_connection_t; &type: cec_device_type): integer;
  cdecl; external libcec Name _PU + 'libcec_set_active_source';

function libcec_set_deck_control_mode(connection: libcec_connection_t; mode: cec_deck_control_mode; bSendUpdate: integer): integer;
  cdecl; external libcec Name _PU + 'libcec_set_deck_control_mode';

function libcec_set_deck_info(connection: libcec_connection_t; info: cec_deck_info; bSendUpdate: integer): integer;
  cdecl; external libcec Name _PU + 'libcec_set_deck_info';

function libcec_set_inactive_view(connection: libcec_connection_t): integer;
  cdecl; external libcec Name _PU + 'libcec_set_inactive_view';

function libcec_set_menu_state(connection: libcec_connection_t; state: cec_menu_state; bSendUpdate: integer): integer;
  cdecl; external libcec Name _PU + 'libcec_set_menu_state';

function libcec_transmit(connection: libcec_connection_t; const Data: Pcec_command): integer;
  cdecl; external libcec Name _PU + 'libcec_transmit';

function libcec_set_logical_address(connection: libcec_connection_t; iLogicalAddress: cec_logical_address): integer;
  cdecl; external libcec Name _PU + 'libcec_set_logical_address';

function libcec_set_physical_address(connection: libcec_connection_t; iPhysicalAddress: uint16): integer;
  cdecl; external libcec Name _PU + 'libcec_set_physical_address';

function libcec_set_osd_string(connection: libcec_connection_t; iLogicalAddress: cec_logical_address;
  duration: cec_display_control; const strMessage: PUTF8Char): integer; cdecl; external libcec Name _PU + 'libcec_set_osd_string';

function libcec_switch_monitoring(connection: libcec_connection_t; bEnable: integer): integer;
  cdecl; external libcec Name _PU + 'libcec_switch_monitoring';

function libcec_get_device_cec_version(connection: libcec_connection_t; iLogicalAddress: cec_logical_address): cec_version;
  cdecl; external libcec Name _PU + 'libcec_get_device_cec_version';

function libcec_get_device_menu_language(connection: libcec_connection_t; iLogicalAddress: cec_logical_address;
  language: cec_menu_language): integer; cdecl; external libcec Name _PU + 'libcec_get_device_menu_language';

function libcec_get_device_vendor_id(connection: libcec_connection_t; iLogicalAddress: cec_logical_address): uint32;
  cdecl; external libcec Name _PU + 'libcec_get_device_vendor_id';

function libcec_get_device_physical_address(connection: libcec_connection_t; iLogicalAddress: cec_logical_address): uint16;
  cdecl; external libcec Name _PU + 'libcec_get_device_physical_address';

function libcec_get_active_source(connection: libcec_connection_t): cec_logical_address; cdecl;
  external libcec Name _PU + 'libcec_get_active_source';

function libcec_is_active_source(connection: libcec_connection_t; iAddress: cec_logical_address): integer;
  cdecl; external libcec Name _PU + 'libcec_is_active_source';

function libcec_get_device_power_status(connection: libcec_connection_t; iLogicalAddress: cec_logical_address): cec_power_status;
  cdecl; external libcec Name _PU + 'libcec_get_device_power_status';

function libcec_poll_device(connection: libcec_connection_t; iLogicalAddress: cec_logical_address): integer;
  cdecl; external libcec Name _PU + 'libcec_poll_device';

function libcec_get_active_devices(connection: libcec_connection_t): cec_logical_addresses; cdecl;
  external libcec Name _PU + 'libcec_get_active_devices';

function libcec_is_active_device(connection: libcec_connection_t; address: cec_logical_address): integer;
  cdecl; external libcec Name _PU + 'libcec_is_active_device';

function libcec_is_active_device_type(connection: libcec_connection_t; &type: cec_device_type): integer;
  cdecl; external libcec Name _PU + 'libcec_is_active_device_type';

function libcec_set_hdmi_port(connection: libcec_connection_t; baseDevice: cec_logical_address; iPort: uint8): integer;
  cdecl; external libcec Name _PU + 'libcec_set_hdmi_port';

function libcec_volume_up(connection: libcec_connection_t; bSendRelease: integer): integer;
  cdecl; external libcec Name _PU + 'libcec_volume_up';

function libcec_volume_down(connection: libcec_connection_t; bSendRelease: integer): integer;
  cdecl; external libcec Name _PU + 'libcec_volume_down';

function libcec_mute_audio(connection: libcec_connection_t; bSendRelease: integer): integer;
  cdecl; external libcec Name _PU + 'libcec_mute_audio';

function libcec_send_keypress(connection: libcec_connection_t; iDestination: cec_logical_address;
  key: cec_user_control_code; bWait: integer): integer; cdecl; external libcec Name _PU + 'libcec_send_keypress';

function libcec_send_key_release(connection: libcec_connection_t; iDestination: cec_logical_address; bWait: integer): integer;
  cdecl; external libcec Name _PU + 'libcec_send_key_release';

function libcec_get_device_osd_name(connection: libcec_connection_t; iAddress: cec_logical_address; Name: cec_osd_name): integer;
  cdecl; external libcec Name _PU + 'libcec_get_device_osd_name';

function libcec_set_stream_path_logical(connection: libcec_connection_t; iAddress: cec_logical_address): integer;
  cdecl; external libcec Name _PU + 'libcec_set_stream_path_logical';

function libcec_set_stream_path_physical(connection: libcec_connection_t; iPhysicalAddress: uint16): integer;
  cdecl; external libcec Name _PU + 'libcec_set_stream_path_physical';

function libcec_get_logical_addresses(connection: libcec_connection_t): cec_logical_addresses; cdecl;
  external libcec Name _PU + 'libcec_get_logical_addresses';

function libcec_get_current_configuration(connection: libcec_connection_t; configuration: Plibcec_configuration): integer;
  cdecl; external libcec Name _PU + 'libcec_get_current_configuration';

function libcec_can_save_configuration(connection: libcec_connection_t): integer;
  cdecl; external libcec Name _PU + 'libcec_can_save_configuration';

function libcec_set_configuration(connection: libcec_connection_t; const configuration: Plibcec_configuration): integer;
  cdecl; external libcec Name _PU + 'libcec_set_configuration';

procedure libcec_rescan_devices(connection: libcec_connection_t); cdecl; external libcec Name _PU + 'libcec_rescan_devices';

function libcec_is_libcec_active_source(connection: libcec_connection_t): integer;
  cdecl; external libcec Name _PU + 'libcec_is_libcec_active_source';

function libcec_get_device_information(connection: libcec_connection_t; const strPort: PUTF8Char;
  config: Plibcec_configuration; iTimeoutMs: uint32): integer; cdecl; external libcec Name _PU + 'libcec_get_device_information';

function libcec_get_lib_info(connection: libcec_connection_t): PUTF8Char; cdecl; external libcec Name _PU + 'libcec_get_lib_info';

procedure libcec_init_video_standalone(connection: libcec_connection_t); cdecl;
  external libcec Name _PU + 'libcec_init_video_standalone';

function libcec_get_adapter_vendor_id(connection: libcec_connection_t): uint16;
  cdecl; external libcec Name _PU + 'libcec_get_adapter_vendor_id';

function libcec_get_adapter_product_id(connection: libcec_connection_t): uint16;
  cdecl; external libcec Name _PU + 'libcec_get_adapter_product_id';

function libcec_audio_toggle_mute(connection: libcec_connection_t): uint8;
  cdecl; external libcec Name _PU + 'libcec_audio_toggle_mute';

function libcec_audio_mute(connection: libcec_connection_t): uint8; cdecl; external libcec Name _PU + 'libcec_audio_mute';

function libcec_audio_unmute(connection: libcec_connection_t): uint8; cdecl; external libcec Name _PU + 'libcec_audio_unmute';

function libcec_audio_get_status(connection: libcec_connection_t): uint8;
  cdecl; external libcec Name _PU + 'libcec_audio_get_status';

function libcec_detect_adapters(connection: libcec_connection_t; deviceList: Pcec_adapter_descriptor;
  iBufSize: uint8; const strDevicePath: PUTF8Char; bQuickScan: integer): int8;
  cdecl; external libcec Name _PU + 'libcec_detect_adapters';

procedure libcec_menu_state_to_string(const state: cec_menu_state; buf: PUTF8Char; bufsize: nativeuint);
  cdecl; external libcec Name _PU + 'libcec_menu_state_to_string';

procedure libcec_cec_version_to_string(const version: cec_version; buf: PUTF8Char; bufsize: nativeuint);
  cdecl; external libcec Name _PU + 'libcec_cec_version_to_string';

procedure libcec_power_status_to_string(const status: cec_power_status; buf: PUTF8Char; bufsize: nativeuint);
  cdecl; external libcec Name _PU + 'libcec_power_status_to_string';

procedure libcec_logical_address_to_string(const address: cec_logical_address; buf: PUTF8Char; bufsize: nativeuint);
  cdecl; external libcec Name _PU + 'libcec_logical_address_to_string';

procedure libcec_deck_control_mode_to_string(const mode: cec_deck_control_mode; buf: PUTF8Char; bufsize: nativeuint);
  cdecl; external libcec Name _PU + 'libcec_deck_control_mode_to_string';

procedure libcec_deck_status_to_string(const status: cec_deck_info; buf: PUTF8Char; bufsize: nativeuint);
  cdecl; external libcec Name _PU + 'libcec_deck_status_to_string';

procedure libcec_opcode_to_string(const opcode: cec_opcode; buf: PUTF8Char; bufsize: nativeuint);
  cdecl; external libcec Name _PU + 'libcec_opcode_to_string';

procedure libcec_system_audio_status_to_string(const mode: cec_system_audio_status; buf: PUTF8Char; bufsize: nativeuint);
  cdecl; external libcec Name _PU + 'libcec_system_audio_status_to_string';

procedure libcec_audio_status_to_string(const status: cec_audio_status; buf: PUTF8Char; bufsize: nativeuint);
  cdecl; external libcec Name _PU + 'libcec_audio_status_to_string';

procedure libcec_vendor_id_to_string(const vendor: cec_vendor_id; buf: PUTF8Char; bufsize: nativeuint);
  cdecl; external libcec Name _PU + 'libcec_vendor_id_to_string';

procedure libcec_user_control_key_to_string(const key: cec_user_control_code; buf: PUTF8Char; bufsize: nativeuint);
  cdecl; external libcec Name _PU + 'libcec_user_control_key_to_string';

procedure libcec_adapter_type_to_string(const &type: cec_adapter_type; buf: PUTF8Char; bufsize: nativeuint);
  cdecl; external libcec Name _PU + 'libcec_adapter_type_to_string';

procedure libcec_version_to_string(version: uint32; buf: PUTF8Char; bufsize: nativeuint); cdecl;
  external libcec Name _PU + 'libcec_version_to_string';
}
procedure Free_LibCEC;
procedure Load_LibCEC(lib: PChar);
function Check_libCEC: boolean;

implementation

uses
  SysUtils, dynlibs;

function LIBCEC_UINT_TO_VERSION_MAJOR(x: longint): longint;
begin
  Result := (x shr 16) and $FF;
end;

function LIBCEC_UINT_TO_VERSION_MINOR(x: longint): longint;
begin
  Result := (x shr 8) and $FF;
end;

function LIBCEC_UINT_TO_VERSION_PATCH(x: longint): longint;
begin
  Result := (x shr 0) and $FF;
end;

function LIBCEC_VERSION_TO_UINT(x, y, z: longint): longint;
begin
  Result := ((x shr 16) and $FF) or ((y shr 8) and $FF) or ((z shr 0) and $FF);
end;

function _LIBCEC_VERSION_CURRENT: longint;
begin
  Result := LIBCEC_VERSION_TO_UINT(CEC_LIB_VERSION_MAJOR, CEC_LIB_VERSION_MINOR, CEC_LIB_VERSION_PATCH);
end;

var
  hlib: tlibhandle;


procedure Free_LibCEC;
begin
  FreeLibrary(hlib);
end;


procedure Load_LibCEC(lib: PChar);
begin
  if hlib <> 0 then
    Free_LibCEC;
  hlib := LoadLibrary(lib);
  if hlib = 0 then
    raise Exception.Create(format('Could not load library: %s', [lib]));

  pointer(libcec_initialise) := GetProcAddress(hlib, 'libcec_initialise');
  pointer(libcec_destroy) := GetProcAddress(hlib, 'libcec_destroy');
  pointer(libcec_open)  := GetProcAddress(hlib, 'libcec_open');
  pointer(libcec_close) := GetProcAddress(hlib, 'libcec_close');
  pointer(libcec_clear_configuration) := GetProcAddress(hlib, 'libcec_clear_configuration');
  pointer(libcec_find_adapters) := GetProcAddress(hlib, 'libcec_find_adapters');
  pointer(libcec_init_video_standalone) := GetProcAddress(hlib, 'libcec_init_video_standalone');

end;

function Check_libCEC: boolean;
begin
  Result := False;
  if Hlib <> 0 then
  begin
    Result := True;
    exit;
  end;
  try
    Load_LibCEC(libcec);
    if (hlib = 0) then
      Exit;
  except
    hlib := 0;
    exit;
  end;

  Result := True;
end;

initialization
  hlib := 0;
end.
